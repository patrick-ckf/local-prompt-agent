= Internationalization (i18n) Enhancement
:toc: left
:toclevels: 3
:sectnums:
:version: 1.0.0
:date: {docdate}
:author: Patrick Cheung

== Document Information

[cols="1,3"]
|===
|Version |{version}
|Date |{date}
|Author |{author}
|Status |Draft
|===

== 1. Overview

This enhancement adds comprehensive internationalization (i18n) and localization (l10n) support to the Local Prompt Agent, enabling users to interact with the system in their preferred language.

=== 1.1 Supported Languages

*Initial Release Languages:*

1. **English (en)** - Default language
2. **Traditional Chinese (zh-TW)** - ç¹é«”ä¸­æ–‡
3. **Simplified Chinese (zh-CN)** - ç®€ä½“ä¸­æ–‡

*Future Consideration:*
- Spanish (es)
- Japanese (ja)
- Korean (ko)
- German (de)
- French (fr)

=== 1.2 Scope

The i18n support covers:

* CLI interface messages and prompts
* API error messages and responses
* Configuration file comments and documentation
* System logs (optional, structured logging)
* Help text and documentation
* Web UI (if implemented)

== 2. Functional Requirements

=== FR-i18n-1: Language Selection

==== FR-i18n-1.1: Configuration
Users can set their preferred language through:

1. **Configuration file**:
```yaml
system:
  language: "zh-TW"  # or "en", "zh-CN"
  fallback_language: "en"
```

2. **Environment variable**:
```bash
export LOCAL_PROMPT_AGENT_LANG=zh-TW
```

3. **CLI flag**:
```bash
local-prompt-agent --lang zh-TW chat "ä½ å¥½"
```

4. **Runtime switching** (for interactive sessions):
```
> /lang zh-TW
Language switched to Traditional Chinese (ç¹é«”ä¸­æ–‡)
```

==== FR-i18n-1.2: Auto-Detection
System can auto-detect language from:
- System locale (`LANG` environment variable)
- User's first message language
- Configuration file setting

=== FR-i18n-2: Translation Coverage

==== FR-i18n-2.1: CLI Messages
All CLI output translated:
- Welcome messages
- Prompts and questions
- Status messages
- Progress indicators
- Completion messages

**Example (English)**:
```
âœ“ Agent initialized successfully
â†’ Waiting for your input...
âš  Warning: High memory usage detected
âœ— Error: Connection to backend failed
```

**Example (Traditional Chinese)**:
```
âœ“ ä»£ç†å·²æˆåŠŸåˆå§‹åŒ–
â†’ ç­‰å¾…æ‚¨çš„è¼¸å…¥...
âš  è­¦å‘Šï¼šåµæ¸¬åˆ°é«˜è¨˜æ†¶é«”ä½¿ç”¨é‡
âœ— éŒ¯èª¤ï¼šç„¡æ³•é€£æ¥åˆ°å¾Œç«¯
```

**Example (Simplified Chinese)**:
```
âœ“ ä»£ç†å·²æˆåŠŸåˆå§‹åŒ–
â†’ ç­‰å¾…æ‚¨çš„è¾“å…¥...
âš  è­¦å‘Šï¼šæ£€æµ‹åˆ°é«˜å†…å­˜ä½¿ç”¨é‡
âœ— é”™è¯¯ï¼šæ— æ³•è¿æ¥åˆ°åç«¯
```

==== FR-i18n-2.2: Error Messages
All error messages with context:

```python
# English
"File not found: {filename}"
"Invalid configuration: {field} must be a valid {type}"

# Traditional Chinese
"æ‰¾ä¸åˆ°æª”æ¡ˆï¼š{filename}"
"é…ç½®ç„¡æ•ˆï¼š{field} å¿…é ˆæ˜¯æœ‰æ•ˆçš„ {type}"

# Simplified Chinese
"æ‰¾ä¸åˆ°æ–‡ä»¶ï¼š{filename}"
"é…ç½®æ— æ•ˆï¼š{field} å¿…é¡»æ˜¯æœ‰æ•ˆçš„ {type}"
```

==== FR-i18n-2.3: Help Text
```bash
# English
$ local-prompt-agent --help
Usage: local-prompt-agent [OPTIONS] COMMAND [ARGS]...

  Local AI prompt agent with multi-model support

Options:
  --version          Show version and exit
  --lang TEXT        Interface language (en, zh-TW, zh-CN)
  --help             Show this message and exit

Commands:
  chat      Start interactive chat session
  serve     Start API server
  config    Manage configuration

# Traditional Chinese
$ local-prompt-agent --help --lang zh-TW
ä½¿ç”¨æ–¹å¼ï¼šlocal-prompt-agent [é¸é …] å‘½ä»¤ [åƒæ•¸]...

  æ”¯æ´å¤šæ¨¡å‹çš„æœ¬åœ° AI æç¤ºä»£ç†

é¸é …ï¼š
  --version          é¡¯ç¤ºç‰ˆæœ¬ä¸¦é€€å‡º
  --lang æ–‡å­—         ä»‹é¢èªè¨€ï¼ˆenã€zh-TWã€zh-CNï¼‰
  --help             é¡¯ç¤ºæ­¤è¨Šæ¯ä¸¦é€€å‡º

å‘½ä»¤ï¼š
  chat      é–‹å§‹äº’å‹•å¼å°è©±
  serve     å•Ÿå‹• API ä¼ºæœå™¨
  config    ç®¡ç†é…ç½®
```

=== FR-i18n-3: API Responses

REST API responses include language support:

```json
{
  "success": true,
  "message": "æ“ä½œæˆåŠŸå®Œæˆ",
  "data": { ... },
  "lang": "zh-TW"
}

{
  "success": false,
  "error": {
    "code": "BACKEND_CONNECTION_FAILED",
    "message": "ç„¡æ³•é€£æ¥åˆ° LLM å¾Œç«¯",
    "message_en": "Failed to connect to LLM backend",
    "details": { ... }
  },
  "lang": "zh-TW"
}
```

**Language negotiation**:
- Accept-Language header
- Query parameter: `?lang=zh-TW`
- Configuration setting

=== FR-i18n-4: Locale-Specific Formatting

==== FR-i18n-4.1: Date and Time
```python
# English
"Last modified: January 10, 2026 at 3:45 PM"

# Traditional Chinese
"æœ€å¾Œä¿®æ”¹ï¼š2026å¹´1æœˆ10æ—¥ ä¸‹åˆ3:45"

# Simplified Chinese
"æœ€åä¿®æ”¹ï¼š2026å¹´1æœˆ10æ—¥ ä¸‹åˆ3:45"
```

==== FR-i18n-4.2: Numbers and Units
```python
# English
"Size: 1,234,567 bytes (1.23 MB)"
"Duration: 1.5 seconds"

# Traditional Chinese
"å¤§å°ï¼š1,234,567 ä½å…ƒçµ„ï¼ˆ1.23 MBï¼‰"
"æŒçºŒæ™‚é–“ï¼š1.5 ç§’"

# Simplified Chinese
"å¤§å°ï¼š1,234,567 å­—èŠ‚ï¼ˆ1.23 MBï¼‰"
"æŒç»­æ—¶é—´ï¼š1.5 ç§’"
```

== 3. Implementation Approach

=== 3.1 Technology Stack

**Python i18n Libraries**:
1. **gettext** (built-in) - Standard Python i18n
2. **Babel** - Modern i18n/l10n toolkit
3. **fluent-runtime** - Project Fluent (recommended)

**Recommended: Babel + gettext**

=== 3.2 Directory Structure

```
src/local_prompt_agent/
â”œâ”€â”€ i18n/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ translations.py        # Translation manager
â”‚   â”œâ”€â”€ locales/
â”‚   â”‚   â”œâ”€â”€ en/
â”‚   â”‚   â”‚   â””â”€â”€ LC_MESSAGES/
â”‚   â”‚   â”‚       â”œâ”€â”€ messages.po
â”‚   â”‚   â”‚       â””â”€â”€ messages.mo
â”‚   â”‚   â”œâ”€â”€ zh_TW/
â”‚   â”‚   â”‚   â””â”€â”€ LC_MESSAGES/
â”‚   â”‚   â”‚       â”œâ”€â”€ messages.po
â”‚   â”‚   â”‚       â””â”€â”€ messages.mo
â”‚   â”‚   â””â”€â”€ zh_CN/
â”‚   â”‚       â””â”€â”€ LC_MESSAGES/
â”‚   â”‚           â”œâ”€â”€ messages.po
â”‚   â”‚           â””â”€â”€ messages.mo
â”‚   â””â”€â”€ formatters.py          # Locale-specific formatting
```

=== 3.3 Translation Workflow

1. **Extract messages**:
```bash
pybabel extract -o messages.pot src/
```

2. **Create/update translations**:
```bash
pybabel init -i messages.pot -d src/local_prompt_agent/i18n/locales -l zh_TW
pybabel update -i messages.pot -d src/local_prompt_agent/i18n/locales
```

3. **Compile translations**:
```bash
pybabel compile -d src/local_prompt_agent/i18n/locales
```

=== 3.4 Code Implementation

==== 3.4.1: Translation Manager

```python
# src/local_prompt_agent/i18n/translations.py
import gettext
from pathlib import Path
from typing import Optional
import locale

class TranslationManager:
    """Manage translations and localization"""
    
    SUPPORTED_LANGUAGES = {
        "en": "English",
        "zh-TW": "ç¹é«”ä¸­æ–‡",
        "zh-CN": "ç®€ä½“ä¸­æ–‡"
    }
    
    def __init__(self, language: Optional[str] = None):
        self.locale_dir = Path(__file__).parent / "locales"
        self.language = language or self._detect_language()
        self._translator = self._load_translator()
    
    def _detect_language(self) -> str:
        """Auto-detect system language"""
        try:
            system_locale = locale.getdefaultlocale()[0]
            if system_locale:
                # Convert locale codes
                if system_locale.startswith("zh_TW"):
                    return "zh-TW"
                elif system_locale.startswith("zh_CN"):
                    return "zh-CN"
                elif system_locale.startswith("en"):
                    return "en"
        except:
            pass
        return "en"  # Default fallback
    
    def _load_translator(self):
        """Load gettext translator"""
        try:
            # Convert zh-TW to zh_TW for gettext
            locale_code = self.language.replace("-", "_")
            return gettext.translation(
                "messages",
                localedir=self.locale_dir,
                languages=[locale_code],
                fallback=True
            )
        except Exception:
            # Fallback to English
            return gettext.NullTranslations()
    
    def translate(self, message: str, **kwargs) -> str:
        """Translate message with optional formatting"""
        translated = self._translator.gettext(message)
        if kwargs:
            return translated.format(**kwargs)
        return translated
    
    def ngettext(self, singular: str, plural: str, n: int) -> str:
        """Handle plural forms"""
        return self._translator.ngettext(singular, plural, n)
    
    def switch_language(self, language: str):
        """Switch to different language"""
        if language in self.SUPPORTED_LANGUAGES:
            self.language = language
            self._translator = self._load_translator()

# Global translator instance
_translator: Optional[TranslationManager] = None

def init_i18n(language: Optional[str] = None):
    """Initialize i18n system"""
    global _translator
    _translator = TranslationManager(language)

def _(message: str, **kwargs) -> str:
    """Shorthand translation function"""
    if _translator is None:
        init_i18n()
    return _translator.translate(message, **kwargs)

def ngettext(singular: str, plural: str, n: int) -> str:
    """Plural translation"""
    if _translator is None:
        init_i18n()
    return _translator.ngettext(singular, plural, n)
```

==== 3.4.2: Usage in Code

```python
from local_prompt_agent.i18n import _, ngettext, init_i18n

# Initialize with user's language
init_i18n("zh-TW")

# Simple translation
print(_("Agent initialized successfully"))

# With variables
print(_("File not found: {filename}", filename="config.yaml"))

# Plural forms
count = 5
print(ngettext(
    "{n} file processed",
    "{n} files processed",
    count
).format(n=count))

# Error messages
raise ValueError(_("Invalid configuration: {field} must be a valid {type}",
                   field="model", type="string"))
```

==== 3.4.3: CLI Integration

```python
import click
from local_prompt_agent.i18n import _, init_i18n

@click.group()
@click.option('--lang', type=click.Choice(['en', 'zh-TW', 'zh-CN']),
              help=_('Interface language'))
def cli(lang):
    """Local AI prompt agent"""
    if lang:
        init_i18n(lang)

@cli.command()
def chat():
    """Start interactive chat"""
    click.echo(_("Starting chat session..."))
    click.echo(_("Type '/exit' to quit"))
```

==== 3.4.4: API Integration

```python
from fastapi import FastAPI, Header
from local_prompt_agent.i18n import init_i18n, _

app = FastAPI()

def get_language(accept_language: str = Header(None)) -> str:
    """Extract language from Accept-Language header"""
    if accept_language:
        # Parse Accept-Language header
        languages = accept_language.split(",")
        if languages:
            lang = languages[0].split(";")[0].strip()
            return lang
    return "en"

@app.post("/api/execute")
async def execute_prompt(
    request: PromptRequest,
    accept_language: str = Header(None)
):
    lang = get_language(accept_language)
    init_i18n(lang)
    
    try:
        result = await agent.execute(request.prompt)
        return {
            "success": True,
            "message": _("Operation completed successfully"),
            "data": result,
            "lang": lang
        }
    except Exception as e:
        return {
            "success": False,
            "error": {
                "message": _("Operation failed: {error}", error=str(e)),
                "message_en": str(e)  # Always include English
            },
            "lang": lang
        }
```

=== 3.5 Translation Files

==== 3.5.1: English (Base) - messages.po

```po
# English translations
msgid ""
msgstr ""
"Language: en\n"
"Content-Type: text/plain; charset=UTF-8\n"

msgid "Agent initialized successfully"
msgstr "Agent initialized successfully"

msgid "File not found: {filename}"
msgstr "File not found: {filename}"

msgid "Starting chat session..."
msgstr "Starting chat session..."
```

==== 3.5.2: Traditional Chinese - zh_TW/messages.po

```po
# Traditional Chinese translations
msgid ""
msgstr ""
"Language: zh-TW\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Plural-Forms: nplurals=1; plural=0;\n"

msgid "Agent initialized successfully"
msgstr "ä»£ç†å·²æˆåŠŸåˆå§‹åŒ–"

msgid "File not found: {filename}"
msgstr "æ‰¾ä¸åˆ°æª”æ¡ˆï¼š{filename}"

msgid "Starting chat session..."
msgstr "æ­£åœ¨å•Ÿå‹•å°è©±..."
```

==== 3.5.3: Simplified Chinese - zh_CN/messages.po

```po
# Simplified Chinese translations
msgid ""
msgstr ""
"Language: zh-CN\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Plural-Forms: nplurals=1; plural=0;\n"

msgid "Agent initialized successfully"
msgstr "ä»£ç†å·²æˆåŠŸåˆå§‹åŒ–"

msgid "File not found: {filename}"
msgstr "æ‰¾ä¸åˆ°æ–‡ä»¶ï¼š{filename}"

msgid "Starting chat session..."
msgstr "æ­£åœ¨å¯åŠ¨å¯¹è¯..."
```

== 4. Testing Requirements

=== 4.1 Unit Tests

```python
def test_translation_manager():
    """Test translation manager"""
    tm = TranslationManager("zh-TW")
    assert tm.translate("Hello") == "æ‚¨å¥½"
    
def test_language_detection():
    """Test auto language detection"""
    tm = TranslationManager()
    assert tm.language in ["en", "zh-TW", "zh-CN"]

def test_language_switching():
    """Test runtime language switching"""
    init_i18n("en")
    assert _("Hello") == "Hello"
    
    init_i18n("zh-TW")
    assert _("Hello") == "æ‚¨å¥½"
```

=== 4.2 Integration Tests

```python
async def test_cli_language():
    """Test CLI with different languages"""
    result = await run_cli("--lang zh-TW chat")
    assert "æ­£åœ¨å•Ÿå‹•å°è©±" in result.output

async def test_api_language():
    """Test API language negotiation"""
    response = await client.post(
        "/api/execute",
        headers={"Accept-Language": "zh-TW"}
    )
    assert response.json()["lang"] == "zh-TW"
```

== 5. Configuration

```yaml
# config.yaml
system:
  # Interface language
  language: "zh-TW"  # en, zh-TW, zh-CN
  
  # Fallback if translation missing
  fallback_language: "en"
  
  # Auto-detect from system
  auto_detect_language: true
  
  # Date/time format
  locale_formatting: true
  
  # Always include English in API errors
  include_english_errors: true
```

== 6. Dependencies

```toml
# pyproject.toml
[tool.poetry.dependencies]
python = "^3.11"
babel = "^2.13.0"         # i18n toolkit
python-dateutil = "^2.8.2" # Date formatting
```

== 7. Implementation Priority

=== Phase 1: Core (Week 1)
1. Set up Babel and directory structure
2. Implement TranslationManager
3. Add English base translations
4. CLI integration

=== Phase 2: Translations (Week 2)
1. Create Traditional Chinese translations
2. Create Simplified Chinese translations
3. Add locale-specific formatting
4. Test language detection

=== Phase 3: API & Advanced (Week 3)
1. API language negotiation
2. Runtime language switching
3. Help text translation
4. Documentation translation

== 8. Character Encoding - Critical for Web UI

=== 8.1 Overview

âš ï¸ **CRITICAL**: Proper character encoding is essential for displaying Chinese characters correctly. Incorrect encoding causes "ï¿½" (replacement characters) or garbled text (ä¹±ç /äº‚ç¢¼).

**Rule**: **Use UTF-8 everywhere** - consistently across all layers.

=== 8.2 Encoding Layers

==== Layer 1: Python Source Files

```python
# -*- coding: utf-8 -*-
"""
Module docstring with Chinese: æœ¬åœ°æç¤ºä»£ç†
All Python files MUST have UTF-8 encoding
"""
```

**Modern Python 3.11+**: UTF-8 is default, but declare explicitly for clarity.

==== Layer 2: Database

```python
# SQLAlchemy with UTF-8
from sqlalchemy import create_engine

# SQLite
engine = create_engine(
    'sqlite:///agent.db',
    connect_args={'check_same_thread': False},
    # SQLite uses UTF-8 by default
)

# PostgreSQL
engine = create_engine(
    'postgresql://user:pass@localhost/agentdb',
    client_encoding='utf8'
)

# MySQL/MariaDB
engine = create_engine(
    'mysql+pymysql://user:pass@localhost/agentdb',
    connect_args={'charset': 'utf8mb4'}  # utf8mb4 for full Unicode
)
```

**Important**: MySQL's `utf8` is limited (3 bytes). Use `utf8mb4` (4 bytes) for full Unicode support including emojis.

==== Layer 3: FastAPI / Web Framework

```python
from fastapi import FastAPI
from fastapi.responses import JSONResponse, HTMLResponse
import json

app = FastAPI()

# JSON responses automatically UTF-8
@app.get("/api/message")
async def get_message():
    return {
        "message": "ä½ å¥½ä¸–ç•Œ",  # Automatically encoded as UTF-8
        "language": "zh-TW"
    }

# Ensure UTF-8 for custom responses
@app.get("/api/custom")
async def custom_response():
    content = {"message": "ç¹é«”ä¸­æ–‡"}
    return JSONResponse(
        content=content,
        media_type="application/json; charset=utf-8"
    )

# HTML responses with UTF-8 meta tag
@app.get("/", response_class=HTMLResponse)
async def root():
    return """
    <!DOCTYPE html>
    <html lang="zh-TW">
    <head>
        <meta charset="UTF-8">
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <title>æœ¬åœ°æç¤ºä»£ç†</title>
    </head>
    <body>
        <h1>æ­¡è¿ä½¿ç”¨æœ¬åœ°æç¤ºä»£ç†</h1>
        <p>æ”¯æ´ç¹é«”ä¸­æ–‡ã€ç®€ä½“ä¸­æ–‡å’ŒEnglish</p>
    </body>
    </html>
    """
```

==== Layer 4: HTTP Headers

```python
from fastapi import Response

@app.middleware("http")
async def add_charset_middleware(request, call_next):
    """Ensure UTF-8 in all responses"""
    response = await call_next(request)
    
    # Add charset to Content-Type if not present
    content_type = response.headers.get("content-type", "")
    if content_type and "charset" not in content_type.lower():
        if "application/json" in content_type:
            response.headers["content-type"] = "application/json; charset=utf-8"
        elif "text/html" in content_type:
            response.headers["content-type"] = "text/html; charset=utf-8"
    
    return response
```

**Critical Headers**:
```
Content-Type: application/json; charset=utf-8
Content-Type: text/html; charset=utf-8
```

==== Layer 5: HTML Meta Tags

```html
<!DOCTYPE html>
<html lang="zh-TW">  <!-- Specify language -->
<head>
    <!-- CRITICAL: UTF-8 meta tag FIRST -->
    <meta charset="UTF-8">
    
    <!-- Backup declaration -->
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    
    <!-- Viewport for mobile -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <title>æœ¬åœ°æç¤ºä»£ç†</title>
</head>
<body>
    <!-- Chinese content displays correctly -->
    <h1>æ­¡è¿ä½¿ç”¨ Welcome æ¬¢è¿ä½¿ç”¨</h1>
</body>
</html>
```

==== Layer 6: File I/O

```python
# Reading files
with open('config.yaml', 'r', encoding='utf-8') as f:
    config = f.read()

# Writing files
with open('output.txt', 'w', encoding='utf-8') as f:
    f.write("ç¹é«”ä¸­æ–‡\nç®€ä½“ä¸­æ–‡\nEnglish\n")

# JSON files
import json

# Save with UTF-8
with open('data.json', 'w', encoding='utf-8', ensure_ascii=False) as f:
    json.dump({"message": "ä½ å¥½"}, f, ensure_ascii=False, indent=2)

# Load with UTF-8
with open('data.json', 'r', encoding='utf-8') as f:
    data = json.load(f)
```

**Important**: Use `ensure_ascii=False` in `json.dump()` to keep Chinese characters readable.

==== Layer 7: Web Sockets

```python
from fastapi import WebSocket

@app.websocket("/ws")
async def websocket_endpoint(websocket: WebSocket):
    await websocket.accept()
    
    # Text messages are UTF-8 by default
    await websocket.send_text("ä½ å¥½ä¸–ç•Œ")
    
    # Receive and decode
    message = await websocket.receive_text()
    # Already decoded as UTF-8
```

=== 8.3 Frontend Web UI Encoding

==== 8.3.1: HTML Template

```html
<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>æœ¬åœ°æç¤ºä»£ç† - Local Prompt Agent</title>
    
    <!-- Font that supports Chinese characters -->
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 
                         "Segoe UI", "Noto Sans CJK TC", "Noto Sans CJK SC",
                         "Microsoft YaHei", "PingFang SC", "Heiti TC", 
                         sans-serif;
        }
    </style>
</head>
<body>
    <div id="app">
        <h1>æ­¡è¿ / æ¬¢è¿ / Welcome</h1>
        <input type="text" placeholder="è¼¸å…¥è¨Šæ¯..." id="message">
        <button onclick="send()">å‚³é€ Send</button>
        <div id="response"></div>
    </div>
    
    <script>
        async function send() {
            const message = document.getElementById('message').value;
            
            // Fetch with UTF-8
            const response = await fetch('/api/execute', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json; charset=utf-8',
                    'Accept': 'application/json',
                    'Accept-Language': 'zh-TW'
                },
                body: JSON.stringify({
                    prompt: message  // JavaScript strings are UTF-16, sent as UTF-8
                })
            });
            
            // Parse JSON (automatically UTF-8)
            const data = await response.json();
            
            // Display (browser handles encoding)
            document.getElementById('response').textContent = data.message;
        }
    </script>
</body>
</html>
```

==== 8.3.2: React/Vue Components

```jsx
// React component with Chinese
import React, { useState } from 'react';

function ChatInterface() {
    const [message, setMessage] = useState('');
    const [response, setResponse] = useState('');
    
    const sendMessage = async () => {
        // Fetch automatically handles UTF-8
        const res = await fetch('/api/execute', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json; charset=utf-8',
                'Accept-Language': localStorage.getItem('language') || 'zh-TW'
            },
            body: JSON.stringify({ prompt: message })
        });
        
        const data = await res.json();
        setResponse(data.message);
    };
    
    return (
        <div>
            <h1>æœ¬åœ°æç¤ºä»£ç†</h1>
            <input 
                value={message}
                onChange={(e) => setMessage(e.target.value)}
                placeholder="è¼¸å…¥è¨Šæ¯..."
            />
            <button onClick={sendMessage}>å‚³é€</button>
            <div>{response}</div>
        </div>
    );
}
```

=== 8.4 Common Encoding Issues and Solutions

==== Issue 1: Garbled Chinese Characters (ä¹±ç /äº‚ç¢¼)

**Problem**:
```
ä½ å¥½ â†’ Ã¤Â½ Ã¥Â¥Â½
ç¹é«”ä¸­æ–‡ â†’ Ã§Â¹Ã©Â«Ã¤Â¸Â­Ã¦
```

**Causes**:
1. Missing UTF-8 declaration
2. File saved in wrong encoding
3. Database not using UTF-8
4. Missing charset in HTTP headers

**Solutions**:
```python
# âœ… Correct: Specify UTF-8 everywhere
response = JSONResponse(
    content={"message": "ä½ å¥½"},
    media_type="application/json; charset=utf-8"
)

# âœ… Correct: Database with UTF-8
engine = create_engine(
    'mysql://localhost/db',
    connect_args={'charset': 'utf8mb4'}
)

# âœ… Correct: File operations
with open('file.txt', 'r', encoding='utf-8') as f:
    content = f.read()
```

==== Issue 2: Replacement Characters (ï¿½)

**Problem**:
```
ä½ å¥½ â†’ ï¿½ï¿½
```

**Cause**: Data encoded in one charset, decoded in another.

**Solution**: Consistent UTF-8 encoding throughout the pipeline.

==== Issue 3: JSON Escape Sequences

**Problem**:
```json
{
  "message": "\u4f60\u597d"
}
```

**Solution**:
```python
# âœ… Keep Chinese readable in JSON
import json

data = {"message": "ä½ å¥½"}
json_str = json.dumps(data, ensure_ascii=False)
# Result: {"message": "ä½ å¥½"}
```

==== Issue 4: URL Encoding

**Problem**: Chinese in URLs breaks links.

**Solution**:
```python
from urllib.parse import quote, unquote

# Encode Chinese for URLs
chinese_text = "ç¹é«”ä¸­æ–‡"
encoded = quote(chinese_text, safe='')  # %E7%B9%81%E9%AB%94%E4%B8%AD%E6%96%87

# Decode
decoded = unquote(encoded)  # ç¹é«”ä¸­æ–‡
```

```javascript
// JavaScript
const chinese = "ç¹é«”ä¸­æ–‡";
const encoded = encodeURIComponent(chinese);
const decoded = decodeURIComponent(encoded);
```

=== 8.5 Testing Encoding

==== Test Cases

```python
# Test 1: Round-trip encoding
def test_encoding_roundtrip():
    """Test Chinese characters survive round-trip"""
    original = "ç¹é«”ä¸­æ–‡ ç®€ä½“ä¸­æ–‡ English"
    
    # Save to file
    with open('test.txt', 'w', encoding='utf-8') as f:
        f.write(original)
    
    # Read back
    with open('test.txt', 'r', encoding='utf-8') as f:
        retrieved = f.read()
    
    assert original == retrieved

# Test 2: JSON encoding
def test_json_encoding():
    """Test JSON preserves Chinese"""
    data = {"message": "ä½ å¥½ä¸–ç•Œ"}
    
    # Serialize
    json_str = json.dumps(data, ensure_ascii=False)
    assert "ä½ å¥½ä¸–ç•Œ" in json_str
    
    # Deserialize
    parsed = json.loads(json_str)
    assert parsed["message"] == "ä½ å¥½ä¸–ç•Œ"

# Test 3: Database encoding
async def test_database_encoding():
    """Test database stores/retrieves Chinese correctly"""
    original = "ç¹é«”ä¸­æ–‡æ¸¬è©¦"
    
    # Save to database
    conversation = Conversation(message=original)
    session.add(conversation)
    await session.commit()
    
    # Retrieve
    retrieved = await session.get(Conversation, conversation.id)
    assert retrieved.message == original

# Test 4: API encoding
async def test_api_encoding():
    """Test API handles Chinese correctly"""
    response = await client.post(
        "/api/execute",
        json={"prompt": "ä½ å¥½ä¸–ç•Œ"},
        headers={"Accept-Language": "zh-TW"}
    )
    
    assert response.status_code == 200
    data = response.json()
    # Should contain Chinese without garbling
    assert "ï¿½" not in json.dumps(data)
```

==== Browser Testing

Test in multiple browsers:
- Chrome/Edge (Chromium)
- Firefox
- Safari
- Mobile browsers (iOS Safari, Chrome Android)

**Test checklist**:
```
â–¡ Chinese displays correctly in UI
â–¡ Chinese input works in text fields
â–¡ Chinese in URLs works
â–¡ Copy-paste Chinese works
â–¡ Chinese in console.log() readable
â–¡ Chinese in error messages clear
â–¡ Mixed language text displays correctly
```

=== 8.6 Configuration Best Practices

```yaml
# config.yaml (saved as UTF-8)
system:
  # Encoding settings
  encoding:
    default: "utf-8"
    file_io: "utf-8"
    database: "utf8mb4"  # For MySQL
    api_response: "utf-8"
  
  # Language settings
  language: "zh-TW"
  
  # Font settings for UI
  fonts:
    chinese: "Noto Sans CJK TC, Microsoft YaHei"
    fallback: "sans-serif"
```

=== 8.7 Deployment Checklist

**Before deploying**:

```bash
# 1. Check all files are UTF-8
find . -name "*.py" -exec file {} \; | grep -v "UTF-8"

# 2. Check HTML files
find . -name "*.html" -exec grep -L "charset=UTF-8" {} \;

# 3. Check Python files have encoding declaration
grep -L "coding: utf-8" src/**/*.py

# 4. Test with real Chinese input
curl -X POST http://localhost:8000/api/execute \
  -H "Content-Type: application/json; charset=utf-8" \
  -d '{"prompt": "æ¸¬è©¦ç¹é«”ä¸­æ–‡"}'

# 5. Check response encoding
curl -I http://localhost:8000/ | grep -i "charset"
```

**Deployment settings**:

```bash
# Environment variables
export LANG=zh_TW.UTF-8
export LC_ALL=zh_TW.UTF-8
export PYTHONIOENCODING=utf-8

# Nginx configuration
location / {
    charset utf-8;
    charset_types text/html text/xml text/plain application/json;
}

# Apache configuration
AddDefaultCharset UTF-8
```

=== 8.8 Summary: UTF-8 Everywhere

âœ… **Checklist**:
```
â–¡ Python source files: UTF-8 (with declaration)
â–¡ Database: UTF-8/utf8mb4
â–¡ API responses: charset=utf-8 in headers
â–¡ HTML: <meta charset="UTF-8">
â–¡ File I/O: encoding='utf-8'
â–¡ JSON: ensure_ascii=False
â–¡ HTTP headers: Content-Type includes charset
â–¡ Environment: LANG=*.UTF-8
â–¡ Web server: charset utf-8
â–¡ Frontend: UTF-8 meta tags
â–¡ Testing: All encoding tests pass
```

**Golden Rule**: When in doubt, specify UTF-8 explicitly! ğŸ¯

== 9. Future Enhancements

1. **Additional Languages**: Add more languages based on user demand
2. **User Contributions**: Community translation platform
3. **Context-Aware Translation**: Different translations based on context
4. **Voice Recognition i18n**: Multi-language voice input
5. **Web UI Translation**: Full web interface i18n support

== 10. Success Criteria

=== Functionality
âœ“ Users can select their preferred language  
âœ“ All CLI messages translated  
âœ“ API responses include appropriate language  
âœ“ Error messages clear in all languages  
âœ“ Help text fully translated  
âœ“ Auto-detection works correctly  
âœ“ Runtime switching works smoothly  
âœ“ Traditional and Simplified Chinese properly distinguished  

=== Encoding (Critical for Web UI)
âœ“ No garbled Chinese characters (ä¹±ç /äº‚ç¢¼)  
âœ“ No replacement characters (ï¿½) in output  
âœ“ Chinese displays correctly in all browsers  
âœ“ Chinese input works in web forms  
âœ“ Database correctly stores/retrieves Chinese  
âœ“ JSON responses preserve Chinese readability  
âœ“ File I/O handles Chinese without errors  
âœ“ UTF-8 specified in all HTTP headers  
âœ“ HTML has proper charset meta tags  
âœ“ All encoding tests pass  

---

**Note**: This enhancement maintains Rule #1: Keep it simple. The i18n system uses standard Python tools (gettext/Babel) and UTF-8 consistently throughout. No complicated encoding conversions needed.
